// *** Browan Communications Inc. ***
//
// *** Industrial Tracker decoder for JavaScript ***
// support parser type: Industrial Tracker
//
// Author: Brian.Jiang
//
// Updated: Cory Callcott (ccall48@hotmail.com) to work with chirpstack v4
// Version v1.0.2
//

//hex to binary function
function hex2bin(hex) {
    return (parseInt(hex, 16).toString(2)).padStart(8, '0');
}

// little-endian format
function littleendian(inputpayload) {
  let data = inputpayload.match(/../g);
  let buf = new ArrayBuffer(4);
  // Create a data view of it
  let view = new DataView(buf);
  // set bytes
  data.forEach(function (b, i) {view.setUint8(i, parseInt(b, 16));});
  // get an int32 with little endian
  let num = view.getInt32(0, 1);
  return num;
}

// GPS Lat calculate
function gnss_LatCal(firstbit, intput_lat) {
  if (firstbit==0) {
    let Lat_littleend_int = littleendian(intput_lat);
    const Lat_bit_01 = (Lat_littleend_int| (0xF0000000)) ^ (0xF0000000);
    const Lat_bit_02 = Lat_bit_01/1000000;
    return (Lat_bit_02.toString());
  } else {
    let Lat_littleend_int = littleendian(intput_lat);
    let Lat_bit_01 = Lat_littleend_int^0xFFFFFFFF;
    const Lat_bit_02 = (Lat_bit_01| (0xF0000000)) ^ (0xF0000000);
    const Lat_bit_03 = Lat_bit_02/1000000;
    return -(Lat_bit_03.toString());
  }
}

// GPS Lat calculate
function gnss_LongCal(firstbit, intput_long){
  if (firstbit==0) {
    let Long_littleend_int = littleendian(intput_long);
    const Long_bit_01 = (Long_littleend_int| (0xE0000000)) ^ (0xE0000000);
    const Long_bit_02 = Long_bit_01/1000000;
    return (Long_bit_02.toString());
  } else {
    let Lat_littleend_int = littleendian(intput_long);
    let Long_bit_01 = Lat_littleend_int^0xFFFFFFFF;
    const Long_bit_02 = (Long_bit_01| (0xE0000000)) ^ (0xE0000000);
    const Long_bit_03 = Long_bit_02/1000000;
    return -(Long_bit_03.toString());
  }
}

// GNSS position estimate calculate
function gnss_PositCal(intput_posit){
  let Posit_int_01 = parseInt(intput_posit,16);
  //const Posit_bit_01 = (Posit_int_01>>5);
  let Posit_bit_01 = (Posit_int_01>>5);
  //const Posit_bit_02 = Math.pow(2,(Posit_bit_01+2));
  let Posit_bit_02 = Math.pow(2,(Posit_bit_01+2));
  return (Posit_bit_02.toString());
}

//decoder function
function decodeUplink(input) {
  let b = new Buffer.from(input.bytes, 'hex');
  let port = input.fPort;
  let decoded = {};

  // create the object to collect the data for returning the decoded payload
  if (port == 136) { // Industrial Tracker Sensor
    let indust_hex = b.toString('hex').substring(0, 2); // Sensors status HEX
    let indust_binary = hex2bin(indust_hex);
    let moving_st = indust_binary.substring(7, 8);      // moving mode
    let nognss_st = indust_binary.substring(4, 5);      // no GNSS fix status
    let gnsserror_st = indust_binary.substring(3, 4);   // GNSS error
    let battry_hex = b.toString().substring(2, 4); // battery calculate
    let battry_int = parseInt(battry_hex, 16);
    let battry_volt = (25+battry_int)/10;
    let temperature_hex = b.toString("hex").substring(4, 6); //temperature calculate
    let temperature_int = parseInt(temperature_hex, 16);
    let temperature_final = temperature_int -32;
    /* Latitude as last reported by GNSS receiver - calculate */
    let gnssLat_hex = b.toString("hex").substring(6, 14);
    let gnssLatbit_hex = b.toString("hex").substring(12, 14); // Latitude Negative sign bit
    let gnssLatbit_neg = (hex2bin(gnssLatbit_hex)).toString().substring(4,5);
    let gnssLat_final = gnss_LatCal(gnssLatbit_neg, gnssLat_hex);
    /* Longitude as last reported by GNSS receiver - calculate */
    let gnssLong_hex = b.toString("hex").substring(14, 22);
    let gnssLongbit_hex = b.toString("hex").substring(20, 22); // Latitude Negative sign bit
    let gnssLongbit_neg = (hex2bin(gnssLongbit_hex)).toString().substring(3,4);
    let gnssLong_final = gnss_LongCal(gnssLongbit_neg, gnssLong_hex);
    /* position accuracy estimate - calculate */
    let gnssPosit_hex = b.toString("hex").substring(20, 22);
    let gnssPosit_final = gnss_PositCal(gnssPosit_hex);

    decoded.moving = parseInt(moving_st);                   // 1 - moving mode, 0 - stationary mode
    decoded.gnss_fix = parseInt(nognss_st);                 // 1 - no GNSS fix, 0 - GNSS fixed
    decoded.gnss_error = parseInt(gnsserror_st);            // 1 - GNSS error, 0 - GNSS OK
    decoded.batt_volt = parseFloat(battry_volt);
    decoded.temperature = parseFloat(temperature_final);
    decoded.latitude = parseFloat(gnssLat_final);
    decoded.longitude = parseFloat(gnssLong_final);
    decoded.pos_est = parseInt(gnssPosit_final);
  }
  return {data: decoded}
}


//Test function output
pl = "AAwykBYlDjIv/wg="
buff = Buffer.from(pl, 'base64');
bytes = new Uint8Array(buff);

console.log(decodeUplink({bytes: bytes, fPort: 136}));

/*
// expected test output
{
    data: {
      moving: 0,
      gnss_fix: 0,
      gnss_error: 0,
      batt_volt: 2.7,
      temperature: 18,
      latitude: -31.123823,
      longitude: 150.94149,
      pos_est: 4
    }
}
*/
